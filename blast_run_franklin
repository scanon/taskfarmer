#!/bin/ksh
SERVER=$1
PORT=$2
TIMEOUT=45
TMPDIR=/tmp/$$
PATH=$PATH:$BASE/bin
PERL=$BASE/lib/perl5
MFILE=message
RFILE=rmess
TMPRFILE=response

# Cleanup any stale stuff
rm -rf $TMPDIR

cd /tmp  
mkdir $TMPDIR
cd $TMPDIR
export LD_LIBRARY_PATH=$BASE/lib/
export PERLLIB=$PERL/site_perl/5.8.8/:$PERL/5.8.8/:$PERL/5.8.8/x86_64-linux-thread-multi

ulimit -m 2048000


function cleanup {
  echo "Called cleanup"
  cd /tmp
  rm -rf $TMPDIR
  exit
}
trap cleanup 2 15

#
#
if [ ! -e $TMPDIR/$DB.pal ] ;then
  let i=$(cat /proc/cray_xt/nid )%2
#  if [ $i -eq 0 ] ; then
#    DBDIR=/scratch/scratchdirs/canon/jgi/nr/
#  fi

#  ln -s $DBDIR/$DB.* $TMPDIR/
fi

eval "$IDCOMMAND"

DBDIR=$(echo $DBDIR|sed 's/\//\\\//g')
BLASTOPTS=$(echo "ARGS"|netcat $SERVER $PORT|sed "s/-d /-d $DBDIR\//")

(echo "IDENT $ID";echo "NEXT")|netcat $SERVER $PORT > $RFILE
while [ -s ./$RFILE ] ; do
  STEP=$(grep '^STEP:' $RFILE|sed 's/STEP: //')
  cat $RFILE|grep -v '^STEP:' > query
  cat query|blastall -o output $BLASTOPTS -a $THREADS 2>&1
  RET=$?
  rm $RFILE query
  echo "IDENT $ID" > $MFILE
  if [ $RET ] ; then
    echo "RESULTS $STEP" >> $MFILE
    cat output >> $MFILE
    echo "DONE" >> $MFILE
  else
    echo "ERROR $STEP" >> $MFILE
    sleep 1
  fi
  if [ ! -e shutdown ] ; then
    echo "NEXT" >> $MFILE 
  fi

# Send Message
 retry=10
 (cat $MFILE)|netcat -w $TIMEOUT $SERVER $PORT > $TMPRFILE
  while [ $retry -gt 0 ] && [ $(grep -c RECEIVED $TMPRFILE) -eq 0 ] ; do
    echo "Retrying $retry"
    (cat $MFILE)|netcat -w $TIMEOUT $SERVER $PORT > $TMPRFILE
    let retry=retry-1
    sleep 20
  done

  if [ -e shutdown ] || [ $retry -eq 0 ] ; then
    echo "Shutting down"
    cleanup
  fi
#
  grep -v RECEIVED $TMPRFILE  > $RFILE
  rm output $MFILE $TMPRFILE
done

cleanup
