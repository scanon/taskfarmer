#!/usr/bin/perl

use Socket;
use IO::Handle;
use IO::Socket::INET;
use strict;
use Getopt::Long;

my $input;
my $output;

Getopt::Long::Configure("pass_through");
my $result = GetOptions ( "i=s" => \$input, "o=s" => \$output);

# Parameters
#
my $SERVERPORT=4999;
my $BATCHSIZE=32;
my $CHUNKSIZE=32;
my $TIMEOUT=1200;
my $MAXRETRY=5;
my $MAXBUFF=100*1024*1024;  # 10M buffer
my $FLUSHTIME=120;
my $FR_FILE="fastrecovery";
my $ARGS;
foreach (@ARGV){
  $_="\'$_\'" if / /;
  $ARGS.=" $_";
}
print "Passing args to client: $ARGS\n";

#  Global vars
#
my $next_header;
my $output_buffer='';
my $progress_buffer='';
my %sequence;
my %job;
my @ondeck;
my @retrylist;
my @failed;
my $item;
my $offset;
my $index;
my $next_flush=time+$FLUSHTIME;
my $next_check=time+$TIMEOUT;
my $processed=0;

open(INPUT,$input) or die "Unable to open input file ($input)\n";

fast_recovery($FR_FILE);

# make the socket
my $sock=new IO::Socket::INET->new(LocalPort=>$SERVERPORT,
	Proto=>'tcp',  Timeout => 45,
         Listen => 200, Reuse => 1
        ) or die "Unable to create socket\n";


my $item=0;
my $remaining=1;
my $shutdown=0;
my $ident;
my $command;

open(PROGRESS,">> ./progress");
open(OUTPUT,">> $output");
open(ERROR,">> ./error.output");
$SIG{INT} = \&catch_int;  # best strategy

# This is the main work loop.
while ($remaining){
  my $new_sock=$sock->accept();
  if (defined $new_sock){
    my $clientaddr=$new_sock->peerhost();

    my $send_query=do_request($new_sock);

#
# Do we need to send a query?  Make sure we aren't in a shutdown.
#
    send_query($new_sock) if ($send_query && $shutdown==0);
    close $new_sock;
  }
#  print "Remaining jobs ".join(" ",keys %job)."\n";    
  check_timeouts() if (time>$next_check);
  flush_output() if (time>$next_flush || length $output_buffer > $MAXBUFF);
  if ( eof(INPUT) || $shutdown){
    $shutdown=1;                      # In case eof got us here.
    $remaining=keys %job;             # How much pending stuff is there?
    print "Draining: $remaining remaining connections\n";
  }
}

foreach my $seq (@ondeck){
  print "bad seq in ondeck: $seq\n" if (!defined $seq || $seq eq '^$');
}

print "Doing final flush\n";
flush_output();
close PRROGRESS;
close OUTPUT;
close ERROR;
close SERVER ;
print "All done\n";

# Interrupt handler
#
sub catch_int {
  my $signame = shift;
  if ($shutdown){
    flush_output();
    close PRROGRESS;
    close OUTPUT;
    close ERROR;
    close SERVER ;
    close PROGRESS;
    print "Exiting\n";
    exit;
  }
  else{
    $shutdown=1;
    flush_output();
    $remaining=keys %job;
    print "Shutting down\n";
    print "Draining: $remaining remaining connections\n";
  }
}

sub do_request{
  my $new_sock=shift;
  my $clientaddr=$new_sock->peerhost();

#  print "Connect from $clientaddr\n";

  my $got_response=0;
  my $send_query=0;
  $ident="noid";
# Read from client.  Process requests and reponse.
#
  while(<$new_sock>){
# print $_;
    if (/^RESULTS /){
      my ($command,$jstep)=split;
      chomp $jstep;
      my $lines=0;
      while(! $got_response){
        $_=<$new_sock>;
        if (/^DONE$/){
          if (defined $job{$jstep}){
            $job{$jstep}->{lines}=$lines;
          }
          print $new_sock "RECEIVED $jstep\n";
          my $status=process_results($jstep);
          print stderr "Unexpected report from $clientaddr:$ident for $jstep\n" if $status eq 0;
          $got_response=1;
        }
        else{
          $output_buffer.=$_;
          $lines++;
        }
        $got_response=1 unless $_;  # catch the edge case
      } # While for response
    }   #
    elsif (/^IDENT /){
      ($command,$ident)=split;
    }
    elsif (/^NEXT$/){
      $send_query=1;
    }
    elsif (/^ARGS$/){
      print $new_sock $ARGS;
    }
    elsif (/^MESSAGE /){
      chomp; 
      s/MESSAGE //;
      print stderr "MESSAGE: $_\n";
    }
    elsif (/^ERROR /){
      my ($command,$jstep)=split;
      print stderr "ERROR: Job step $jstep\n";
      print ERROR "ERROR: Job step $jstep\n";
      print $new_sock "RECEIVED $jstep\n";
      requeue_job($jstep);
    }
    else{
      print stderr "Recieved unusual response from $clientaddr: $_";
    }
  }

  return $send_query;

}

# Process results from client.
# Add line to progress buffer.
# Cleanup data structures.
# (This doesn't actually spool the output)
#
sub process_results{
  my $jstep=shift;

  if (defined ($job{$jstep})){
    my $sequences=join ",",@{$job{$jstep}->{list}};
    $progress_buffer.=sprintf "%s %s %d %d %d %d\n", 
	$sequences,$ident,time-$job{$jstep}->{start},
	$job{$jstep}->{lines},time,$job{$jstep}->{len};
    printf "Recv: %d seq:%25s hostid:%-10s  time:%-4ds lines: %-6d proc: %d\n", 
	$jstep, substr($sequences,0,25),$ident,
	time-$job{$jstep}->{start},$job{$jstep}->{lines},$processed;
    foreach my $seqid (@{$job{$jstep}->{list}}){
      delete $sequence{$seqid};
    }
    $processed+=$job{$jstep}->{count};
    delete $job{$jstep};
    return 1;
  }
  else{
    return 0;
  }
}

sub send_query{
  my $new_sock=shift;

  my $sent=[];
  my $length;
  my $ct=0;
  my @list=build_list($BATCHSIZE);

# Send the list if there is one.
#
  if (scalar @list > 0){
    print $new_sock "STEP: $item\n";
    foreach my $seq (@list){
      print $new_sock $sequence{$seq}->{sequence};
      push @{$sent}, $seq;
      $length+=length $sequence{$seq}->{sequence};
      $ct++;
    }
# Save info about the job step.
#
    $job{$item}->{start}=time;
    $job{$item}->{len}=$length;
    $job{$item}->{list}=$sent; 
    $job{$item}->{count}=$ct; 
    print "Sent: $item hostid:$ident length:$length\n";
    $item++;
  }
}

# Flush output, progress, and create fast_recovery file
# This tries to keep everything in a consistent state.
#
sub flush_output{
  print OUTPUT $output_buffer; 
  print PROGRESS $progress_buffer; 
  flush OUTPUT;
  flush PROGRESS;

  printf "Flushed %ld bytes\n",length $output_buffer;
  $output_buffer='';
  $progress_buffer='';

  my $ct=write_fastrecovery($FR_FILE);
  printf "Wrote fast recovery (%d items)\n", $ct;
  $next_flush=time+$FLUSHTIME;
}

#
# This builds up a work list of args sequences.
# It first will look at anything on retrylist then
# go to the ondeck queue.
#
sub build_list{
  my $batchsize=shift;
  my @list;
  my $ct=0;


# Check retry stack
#
  while ($ct<$batchsize && scalar @retrylist >0){
    push @list,shift @retrylist;
    $ct++;
  }

# Build rest from ondeck
#
  if (scalar @ondeck < ($batchsize-$ct)){
    read_input($CHUNKSIZE);
  }
  while ($ct<$batchsize && scalar @ondeck >0){
    push @list,shift @ondeck;
    $ct++;
  }
  return @list;
}

# Look for old inflight messages.
# Move to retry queue
#
sub check_timeouts{
  my $time=time-$TIMEOUT;
  foreach my $jstep (keys %job){
    if ($job{$jstep}->{start}<$time){
      print "RETRY: $jstep timed out.  Adding to retry.\n";
      requeue_job($jstep);
    }
  }
  $next_check=time+$TIMEOUT/2;
}

# Take sequences for job step
# and put back on the queue.
#
sub requeue_job{
  my $jstep=shift;

  foreach my $seqid (@{$job{$jstep}->{list}}){
    $sequence{$seqid}->{retry}++;
    if ($sequence{$seqid}->{retry} < $MAXRETRY){
      push @retrylist,$seqid;
    }
    else{
      print stderr "MAX:  $seqid hit max retries\n";
      print ERROR "FAILED: $seqid hit max retries\n";
      push @failed,$seqid;
    }
  }
  delete $job{$jstep};
}

#
# Read in $read number of sequences
# Store sequence and push header onto ondeck stack
#
sub read_input{
  my $read=shift;
  my $ct=0;

  return 0 if eof(INPUT);

  if (! defined $next_header){
    $_=<INPUT>;
    while (/^$/){
      $_=<INPUT>;
    }
    die "Bad start: $_\n" unless /^>/;
    my ($bl,$header,$rest)=split /[> \r\n]/;
    $next_header=$header;
    $sequence{$next_header}->{sequence}=$_;
    $sequence{$next_header}->{retry}=0;
  }

  while ($ct<$read && !eof(INPUT)){
    $_=<INPUT>;
    while(! /^>/ ){
       $sequence{$next_header}->{sequence}.=$_;
       $_=<INPUT>;
       last if eof(INPUT);
    }
    push @ondeck, $next_header if (defined $next_header && $next_header ne '');
    $ct++;
    my ($bl,$header,$rest)=split /[> \r\n]/;
    $next_header=$header;
    if (defined $next_header){
      $sequence{$next_header}->{sequence}=$_;
      $sequence{$next_header}->{retry}=0;
    }
  }
  $index+=$ct;
#  print "Read $ct sequences from input.  Size of sequence " . scalar( keys %sequence) . "\n";
  return $ct;
}

#
# Read fast recovery file
# Figure out where we were in the input stream.
# Requeue any outstanding work.
#
sub fast_recovery{
  my $filename=shift; 
  return unless ( -e $filename);
  print "Recoverying using $filename\n";
  open(FR,$filename) or die "Unable to open $filename\n";
# Read the max index and offset
#
  $_=<FR>;
  $_=~s/.*max: //;  
  ($index,$offset)=split;
  if (eof(FR)){
    close FR;
    seek INPUT,$offset,0;
    return;
  }

  $_=<FR>;
  die "Bad start: $_\n" unless /^>/;
  my ($bl,$header,$rest)=split /[> \r\n]/;

  while (!eof(FR)){
    $sequence{$header}->{sequence}=$_;
    $sequence{$header}->{retry}=0;
    $_=<FR>;
    while(! /^>/){
       $sequence{$header}->{sequence}.=$_;
       $_=<FR>;
       last if eof(FR);
    }
    push @ondeck, $header if (defined $header && $header ne '');
    ($bl,$header,$rest)=split /[> \r\n]/;
  }
  seek INPUT,$offset,0;
  printf "Recovered %d sequences from $filename\n", scalar @ondeck;
  close FR;
}

# Write the fastrecovery file.
# The first line is the index number and the offset into the
#   query file.
# This is followed by a list of sequences that were in process
# This list must include retries, pending jobs, and ondeck.
# The last is needed because the file pointer has already moved past
#   the ondeck list of sequences.
#
sub write_fastrecovery{
  my $filename=shift;
  open(FR,"> $filename.new");
  printf FR "# max: %ld %ld\n",$index,tell(INPUT)-length($sequence{$next_header}->{sequence});
  my $seqid;
  my $ct=0;

# Print out anything on retry queue
  foreach my $seqid (@retrylist){
    die "Bad sequence in retry $seqid\n\n$sequence{$seqid}->{sequence}\n" unless $sequence{$seqid}->{sequence}=~/^>/;
    print FR $sequence{$seqid}->{sequence};
    $ct++;
  }
 
# Print out any pending jobs
# 
  foreach my $jstep (keys %job){
    foreach $seqid (@{$job{$jstep}->{list}}){
      die "Bad sequence in pending $seqid\n\n$sequence{$seqid}->{sequence}\n\n" unless $sequence{$seqid}->{sequence}=~/^>/;
      print FR $sequence{$seqid}->{sequence};
      $ct++;
    }
  }

# Print out anything in the ondeck circle
  foreach my $seqid (@ondeck){
    die "Bad sequence in ondeck $seqid\n" unless $sequence{$seqid}->{sequence}=~/^>/;
    print FR $sequence{$seqid}->{sequence};
    $ct++;
  }
  close FR;

# Try to safely move the file in place.
#
  unlink $filename;
  link $filename.".new", $filename or die "Unable to move $filename.new\n";
  unlink $filename.".new";
  return $ct;
}
